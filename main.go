package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"

	"golang.org/x/tools/imports"
)

var (
	flagInputPath string
)

func init() {
	flag.StringVar(&flagInputPath, "in", "", "/path/to/input.go")
}

func main() {
	log.SetFlags(0)
	log.SetPrefix("bldrgen: ")

	flag.Parse()

	if flagInputPath == "" {
		log.Fatal("must specify input path")
	}

	f, err := parser.ParseFile(token.NewFileSet(), flagInputPath, nil, parser.AllErrors)
	if err != nil {
		log.Fatal(err)
	}

	impDecl := &ast.GenDecl{
		Tok:   token.IMPORT,
		Specs: []ast.Spec{},
	}
	for _, imp := range f.Imports {
		s := &ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:  token.STRING,
				Value: imp.Path.Value,
			},
		}
		if imp.Name != nil {
			s.Name = ast.NewIdent(imp.Name.Name)
		}
		impDecl.Specs = append(impDecl.Specs, s)
	}

	outfile := &ast.File{
		Name: ast.NewIdent(f.Name.Name),
		Decls: []ast.Decl{
			impDecl,
		},
	}

	const (
		receiverName    = "b"
		targetFieldName = "t"
	)

	for _, decl := range f.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}
		for _, spec := range genDecl.Specs {
			// only process type specs...
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			// ...that are struct types
			structDefinition, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			targetTypeName := typeSpec.Name.Name
			builderTypeName := targetTypeName + "Builder"

			outfile.Decls = append(outfile.Decls, genBldrStruct(builderTypeName, targetFieldName, targetTypeName))
			outfile.Decls = append(outfile.Decls, genConstructor(builderTypeName))
			outfile.Decls = append(outfile.Decls, genTargetGetter(receiverName, builderTypeName, targetFieldName, targetTypeName))

			for _, field := range structDefinition.Fields.List {
				for _, fieldIdent := range field.Names {
					outfile.Decls = append(outfile.Decls, genSetter(receiverName, builderTypeName, fieldIdent.Name, targetFieldName, field.Type))
				}
			}
		}
	}

	fset := token.NewFileSet()
	var buf bytes.Buffer
	format.Node(&buf, fset, outfile)

	// clean up the imports, just in case
	res, err := imports.Process(flagInputPath, buf.Bytes(), nil)
	if err != nil {
		log.Panic(err)
	}

	fmt.Printf("// Code generated by \"bldrgen %s\"; DO NOT EDIT.\n\n", strings.Join(os.Args[1:], " "))
	os.Stdout.Write(res)
}

func genBldrStruct(typeName, fieldName, fieldTypeName string) *ast.GenDecl {
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent(typeName),
				Type: &ast.StructType{
					Fields: &ast.FieldList{
						List: []*ast.Field{
							&ast.Field{
								Names: []*ast.Ident{
									ast.NewIdent(fieldName),
								},
								Type: ast.NewIdent(fieldTypeName),
							},
						},
					},
				},
			},
		},
	}
}

func genConstructor(typeName string) *ast.FuncDecl {
	return &ast.FuncDecl{
		Name: ast.NewIdent("New" + typeName),
		Type: &ast.FuncType{
			Results: &ast.FieldList{
				List: []*ast.Field{
					&ast.Field{
						Type: &ast.StarExpr{
							X: ast.NewIdent(typeName),
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.UnaryExpr{
							Op: token.AND,
							X: &ast.CompositeLit{
								Type: ast.NewIdent(typeName),
							},
						},
					},
				},
			},
		},
	}
}

func genTargetGetter(receiverName, builderTypeName, targetFieldName, targetTypeName string) *ast.FuncDecl {
	return &ast.FuncDecl{
		Recv: genStarRecv(receiverName, builderTypeName),
		Name: ast.NewIdent("Get" + strings.Title(targetTypeName)),
		Type: &ast.FuncType{
			Results: &ast.FieldList{
				List: []*ast.Field{
					&ast.Field{
						Type: &ast.StarExpr{
							X: ast.NewIdent(targetTypeName),
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						&ast.UnaryExpr{
							Op: token.AND,
							X: &ast.SelectorExpr{
								X:   ast.NewIdent(receiverName),
								Sel: ast.NewIdent(targetFieldName),
							},
						},
					},
				},
			},
		},
	}
}

func genStarRecv(name, typeName string) *ast.FieldList {
	return &ast.FieldList{
		List: []*ast.Field{
			&ast.Field{
				Names: []*ast.Ident{
					ast.NewIdent(name),
				},
				Type: &ast.StarExpr{
					X: ast.NewIdent(typeName),
				},
			},
		},
	}
}

func genSetter(receiverName, builderTypeName, fieldName, targetFieldName string, fieldType ast.Expr) *ast.FuncDecl {
	return &ast.FuncDecl{
		Recv: genStarRecv(receiverName, builderTypeName),
		Name: ast.NewIdent("Set" + strings.Title(fieldName)),
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					&ast.Field{
						Names: []*ast.Ident{
							ast.NewIdent(fieldName),
						},
						Type: fieldType,
					},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					&ast.Field{
						Type: &ast.StarExpr{
							X: ast.NewIdent(builderTypeName),
						},
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						&ast.SelectorExpr{
							X: &ast.SelectorExpr{
								X:   ast.NewIdent(receiverName),
								Sel: ast.NewIdent(targetFieldName),
							},
							Sel: ast.NewIdent(fieldName),
						},
					},
					Tok: token.ASSIGN,
					Rhs: []ast.Expr{
						ast.NewIdent(fieldName),
					},
				},
				&ast.ReturnStmt{
					Results: []ast.Expr{
						ast.NewIdent(receiverName),
					},
				},
			},
		},
	}
}
